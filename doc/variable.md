
### JavaScript 变量

变量是存储信息的容器

#### JavaScript 变量

JavaScript 变量可用于存放值（比如 x=2）和表达式（比如 z=x+y），变量可以使用短名称（比如 x 和 y），也可以使用描述性更好的名称（比如 age, sum, totalvolume）。

- 变量必须以字母开头
- 变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）
- 变量名称对大小写敏感（y 和 Y 是不同的变量）
 
提示：JavaScript 语句和 JavaScript 变量都对大小写敏感。

#### 声明（创建） JavaScript 变量

- 使用 `var` 关键词来声明变量

- 使用 `function` 关键词来声明变量

- 使用 `let` 命令来声明变量

    它的用法类似于 `var` ，但是所声明的变量
    
    + 只在 `let` 命令所在的代码块内有效。`for` 循环的计数器，就很合适使用 `let` 命令。
    
    + `let` 不像 `var` 那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。
    
    + 只要块级作用域内存在 `let` 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
    
    + `let` 不允许在相同作用域内，重复声明同一个变量。
    
- 使用 `const` 命令来声明变量

    + `const` 声明一个只读的常量。一旦声明，常量的值就不能改变。
    
    + `const` 的作用域与 `let` 命令相同：只在声明所在的块级作用域内有效。
    
    + `const` 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
    
    + 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。`const` 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。
    
    如果真的想将对象冻结，应该使用Object.freeze方法。
    
- 使用 `import` 命令来声明变量

- 使用 `class` 命令来声明变量
    
#### 块级作用域

ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

- 第一种场景，内层变量可能会覆盖外层变量。

- 第二种场景，用来计数的循环变量泄露为全局变量。

`let` 实际上为JavaScript新增了块级作用域。

#### 块级作用域与函数声明

ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。
ES6引入了块级作用域，明确允许在块级作用域之中声明函数。

并且ES6规定，块级作用域之中，函数声明语句的行为类似于 `let` ，在块级作用域之外不可引用。

很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

- 允许在块级作用域内声明函数。
- 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
    
#### 全局对象的属性

 全局对象是最顶层的对象，在浏览器环境指的是 `window` 对象，在Node.js指的是 `global` 对象。
ES5之中，全局对象的属性与全局变量是等价的。

 ES6为了改变这一点，一方面规定，为了保持兼容性，`var` 命令和 `function` 命令声明的全局变量，依旧是全局对象的属性；另一方面规定，`let` 命令、`const` 命令、`class` 命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。
